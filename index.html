<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <!-- crossorigin="anonymous"> -->

    <title>Bluetooth</title>


    <style>
        .btn,
        .btn2 {
            font-size: 1.5rem;
        }

        .display {
            display: grid;
            grid-gap: 4px;
        }

        [wm-ativado] {
            background-color: lime;
        }

        .option {
            display: inline;
        }
    </style>
</head>

<body>
    <div class="display">

        <h1 id="VersionBluetooth">Version: 0.0.100</h1>
        <input type="text" id="name" value="" placeholder="Device">
        <!-- <div>
            Configuração de escrita
            <div class="option">
                <input type="radio" name="grp" id="btnHexa" value="0" checked>Hexa
                <input type="radio" name="grp" id="btnAscii" value="1">Ascii
            </div>
        </div> -->

        <div class="display" id="btnDiv">

            <button class="btn" id='btnConnect' onclick="btnConnectClick()">Parear Bluetooth</button>
            <button class="btn" id='btnDisConnect' onclick="btnDisconnectClick()" disabled>Desconectar
                Bluetooth</button>
            <button class="btn" id='btnReconnect' onclick="btnReconnectClick()" disabled>Reconectar</button>
            <button class="btn2" id='btnTeste' onclick="btnTesteClick()">Teste</button>
        </div>
        <div id="logs"></div>
    </div>



</body>
<script src="./index.js"></script>
<!-- <script src="./bluetooth.js"></script> -->

<!-- <script src="/socket.io/socket.io.js"></script>
<script>
    var socket = io.connect('http://localhost');
    console.log('conectei')
    socket.on('Conectado', function (data) {
        console.log(data);
        // socket.emit('my other event', { my: 'data' });
    });
</script> -->



<script>
    // esse script será o bluetooth.js
    //fonte: https://googlechrome.github.io/samples/web-bluetooth/
    "use strict";

    var bluetoothDevice
    let myCharacteristic = []
    const serviceUUiD = '0000fefb-0000-1000-8000-00805f9b34fb'
    let bufferRX = ''
    let logArq = ''

    function ConnectBluetooth(name, classDisable, elementEnabled) {


        log.innerHTML += `Criando conexao: ${name} <br/>`

        let optionalServices = serviceUUiD
            .split(/, ?/).map(s => s.startsWith('0x') ? parseInt(s) : s)
            .filter(s => s && BluetoothUUID.getService);

        let options = { filters: [{ services: optionalServices }] }
        if (name) {
            // options = { filters: [], optionalServices: optionalServices }
            options.filters.push({ name })
        } else {
            // options = { filters: [{ services: optionalServices }] }
        }
        navigator.bluetooth.requestDevice(options)
            .then(device => {
                bluetoothDevice = device;
                log.innerHTML += 'Conectando: ' + bluetoothDevice.name + '</br>'
                return bluetoothDevice.gatt.connect()
            })
            .then(server => {
                log.innerHTML += 'Conectado: ' + bluetoothDevice.name + '</br>'
                log.innerHTML += 'ID: ' + bluetoothDevice.id + '</br>'
                log.innerHTML += 'Pareado: ' + bluetoothDevice.gatt.connected + '</br>'
                log.innerHTML += 'Get services...' + '</br>'
                return server.getPrimaryServices()
            })
            .then(services => {
                let queue = Promise.resolve();
                disabledAllBtn(classDisable)
                elementEnabled.forEach(e => {
                    e.disabled = false
                })
                services.forEach(service => {
                    queue = queue.then(_ => service.getCharacteristics().then(characteristics => {
                        log.innerHTML += '> Service: ' + service.uuid + '</br>';
                        characteristics.forEach((characteristic, id) => {
                            myCharacteristic.push(characteristic)

                            let sup = getSupportedProperties(characteristic)

                            let element = characteristic.uuid + ' ' + sup + '<br/>'
                            divBtn.innerHTML += `<button class = 'btn btnRX' id='btnChar${id}' onclick=
                                'ServiceOf("${id}")'>${element}</button></br>`


                        });
                    }));
                });
                return queue;
            })
            .catch(error => {
                log.innerHTML += 'Argh! ' + error + '</br>';
            })


    }

    function DisconnectBluetooth(classDisable, elementEnabled) {

        disabledAllBtn(classDisable)
        elementEnabled.forEach(e => {
            e.disabled = false
            log.innerHTML += `Elemento ${e.innerHTML} habilitado<br/>`
        })
        if (!bluetoothDevice) {
            return;
        }
        log.innerHTML += 'Desconectando Bluetooth<br/>'
        if (bluetoothDevice.gatt.connected) {
            bluetoothDevice.gatt.disconnect();
            log.innerHTML += 'Bluetooth desconectado!<br/>'
        } else {
            log.innerHTML += 'Bluetooth já desconectado!!!<br/>'
        }
    }

    function ReconnectBluetooth(classDisable, elementEnabled) {
        disabledAllBtn(classDisable)
        elementEnabled.forEach(e => {
            e.disabled = false
        })
        if (!bluetoothDevice) {
            return;
        }
        log.innerHTML += 'Reconectando Bluetooth...<br/>'
        if (bluetoothDevice.gatt.connected) {
            log.innerHTML += 'Bluetooth já está conectado!!!<br/>'
        } else {
            log.innerHTML += 'Connecting to Bluetooth Device...<br/>';
            return bluetoothDevice.gatt.connect()
                .then(server => {
                    log.innerHTML += '> Bluetooth Device connected<br/>';
                });
        }
    }

    function Teste(data) {
        log.innerHTML += 'Testando...<br/>'


        ServiceOf(3, '', () => {
            ServiceOf(1, '', () => {
                ServiceOf(2, '20', () => {
                // ServiceOf(2, ' ', () => {
                    //aqui entra como prestador de serviços
                    // setInterval(txOBD(), 200)
                })
            })
        })


        // let writeBuffer = [32]
        // var tmpWriteBfr = Uint8Array.from(writeBuffer.splice(0, writeBuffer.length));
        // log.innerHTML += tmpWriteBfr + '<br/>'

        // writeBuffer = prompt('Digite o comando', '0F55010110AA')
        // let bytes = []; // char codes
        // if (writeBuffer != null && writeBuffer != '') {

        //     for (let i = 0; i < writeBuffer.length; ++i) {
        //         bytes = bytes.concat([writeBuffer.charCodeAt(i)]);
        //     }
        //     tmpWriteBfr = bytes
        //     // log.innerHTML += tmpWriteBfr + '<br/>'
        //     // tmpWriteBfr = tmpWriteBfr.map(e => toHex(e))
        //     // log.innerHTML += tmpWriteBfr + '<br/>'
        //     tmpWriteBfr = Uint8Array.from(tmpWriteBfr.splice(0, tmpWriteBfr.length));
        //     log.innerHTML += tmpWriteBfr + '<br/>'

        // //     tmpWriteBfr = tmpWriteBfr.map(e => convertBase.dec2hex(e))
        //     // log.innerHTML += toHex(109) + '<br/>'
    }

    // myCharacteristic[2].writeValue(tmpWriteBfr)
    //     .then(_ => {
    //         log.innerHTML += 'Teste: Write Success <br/>'
    //     })
    //     .catch(error => {
    //         log.innerHTML += 'Argh! ' + error + '<br/>'
    //     })

    //}


    function ServiceOf(id, cmd, callback) {
        let btnChar = document.getElementById(`btnChar${id}`)

        let serviceOn = btnChar.getAttribute('wm-ativado') == null

        if (serviceOn) {
            if (id == 3 || id == 1) {
                myCharacteristic[id].startNotifications()
                    .then(_ => {
                        log.innerHTML += myCharacteristic[id].uuid.split('-')[0] + ' sucess!!!</br>'
                        if (id == 1)
                            myCharacteristic[id].addEventListener('characteristicvaluechanged',
                                handleNotifications);
                        else
                            myCharacteristic[id].addEventListener('characteristicvaluechanged',
                                rxOBD);
                        //mostrando ativo no botao                    
                        btnChar.setAttribute('wm-ativado', '')
                        // if (callback == typeof (Function)) 
                        callback()
                    })
                    .catch(error => {
                        log.innerHTML += 'Argh! ' + error + '</br>'
                        log.innerHTML += myCharacteristic[id].uuid + ' não suportado! </br>'
                        log.innerHTML += 'Tentando gravar </br>'
                    })
            } else {
                //gravar
                let writeBuffer
                if (cmd == undefined)
                    writeBuffer = prompt('Digite o comando', '0F55010110AA')
                else
                    writeBuffer = cmd
                if (writeBuffer != null && writeBuffer != '') {
                    let bytes = []; // char codes
                    for (let i = 0; i < writeBuffer.length; i +=2) {
                        let s = writeBuffer[i] + writeBuffer[i + 1]
                        bytes = bytes.concat(Number('0x' + s));
                    }
                    let tmpWriteBfr = bytes
                    // let tx = tmpWriteBfr.map(e => toHex(e))
                    // log.innerHTML += writeBuffer + '<br/>'
                    tmpWriteBfr = Uint8Array.from(tmpWriteBfr.splice(0, bytes.length));                    
                    log.innerHTML += `>>>${JSON.stringify(tmpWriteBfr)}<br/>`
                    myCharacteristic[id].writeValue(tmpWriteBfr)
                        .then(_ => {
                            tmpWriteBfr = tmpWriteBfr.map(e => toHex(e))
                            log.innerHTML += `>${writeBuffer}<br/>`
                            // if (callback == typeof (Function)) 
                            callback()
                        })
                        .catch(error => {
                            log.innerHTML += 'Argh! ' + error + '<br/>'
                        })
                } else
                    log.innerHTML += 'Cancelado!<br/>'
            }
        } else {
            // if (myCharacteristic[id]) {
            log.innerHTML += 'Stopping Notifications...';
            btnChar.removeAttribute('wm-ativado')
            myCharacteristic[id].stopNotifications()
                .then(_ => {
                    log.innerHTML += myCharacteristic[id].uuid.split('-')[0] + ' stopped!!!</br>';
                    myCharacteristic[id].removeEventListener('characteristicvaluechanged',
                        handleNotifications);
                })
                .catch(error => {
                    log.innerHTML += 'Argh! ' + error + '</br>';
                });
            // }
        }






    }
    function rxOBD(event) {
        let value = event.target.value;
        let a = [];
        let rx = ''
        for (let i = 0; i < value.byteLength; i++) {
            a.push(('00' + value.getUint8(i).toString(16)).slice(-2));
            rx += value[i] + ' '
        }
        log.innerHTML += '<' + a.join(' ') + ' creditos!</br>'
        //log.innerHTML += `<2: ${rx}</br>`
    }

    function handleNotifications(event) {
        let value = event.target.value;
        let a = [];
        let rx = ''
        // Convert raw data bytes to hex values just for the sake of showing something.
        // In the "real" world, you'd use data.getUint8, data.getUint16 or even
        // TextDecoder to process raw data bytes.
        for (let i = 0; i < value.byteLength; i++) {
            a.push(('00' + value.getUint8(i).toString(16)).slice(-2));
            rx += value[i] + ' '
        }
        log.innerHTML += '<' + a.join(' ') + '</br>'
        bufferRX = a.join(' ')
        txOBD()
        // log.innerHTML += `<${rx}</br>`
    }









    var convertBase = function () {

        function convertBase(baseFrom, baseTo) {
            return function (num) {
                return parseInt(num, baseFrom).toString(baseTo);

            };
        }

        // binary to decimal
        convertBase.bin2dec = convertBase(2, 10);

        // binary to hexadecimal
        convertBase.bin2hex = convertBase(2, 16);

        // decimal to binary
        convertBase.dec2bin = convertBase(10, 2);

        // decimal to hexadecimal
        convertBase.dec2hex = convertBase(10, 16);

        // hexadecimal to binary
        convertBase.hex2bin = convertBase(16, 2);

        // hexadecimal to decimal
        convertBase.hex2dec = convertBase(16, 10);

        return convertBase;
    }();

    // Rotinas do protocolo OBDMAP Bluetooth
    function txOBD() {
        if (bufferRX != '') {
            //interpretar o comando pedido
            let cmdTX = toRx()
            ServiceOf(0, cmdTX, () => {
                bufferRX = '';
            })
        }
    }
    function toRx() {
        let cmd = bufferRX.split(' ')
        let bufferTX = []
        let funcao = []
        if (cmd[1] == '23') {
            fileOpen(() => {
                bufferTX = loadTX(cmd)
                console.log(`< ${spaceBetween(bufferTX)}`)
                return bufferTX;
            })
        }
        else {
            if (cmd[1] == '30') {
                fileOpen(() => {
                    bufferTX = requestFx(cmd)
                    console.log(`< ${spaceBetween(bufferTX)}`)
                    return bufferTX;
                })
            }
            else {
                switch (cmd[1]) {
                    case '81': bufferTX = init(cmd); break;
                    case '3D': bufferTX = logRX(cmd); break;
                    case '3E': bufferTX = testPresent(cmd); break;
                    case '82': bufferTX = finish(cmd); break;
                    default: bufferTX = `027F${cmd[1]}11`
                }
                console.log(`< ${spaceBetween(bufferTX)}`)
                return bufferTX;
            }
        }
    }



    function init(cmd) {
        if (chkCheck(cmd)) return '01C1C2'
        else return '037F8110'
    }

    function requestFx(cmd) {
        if (chkCheck(cmd)) {
            let cont = toHex(funcao.length)
            let chk = 0
            logArq = ''
            return `0270${cont}${toHex(chk)}`
        }
        else return '037F8110'
    }

    function testPresent(cmd) {
        if (chkCheck(cmd)) return '017E7F'
        else return '037F3E10'
    }

    function loadTX(cmd) {
        if (chkCheck(cmd)) {
            if (funcao.length > cmd[2]) {
                let ind = parseInt(cmd[2])
                let s = spaceBetween(826380 + funcao[ind])
                let chk = getChk(s.split(' '))
                return `826380${funcao[ind]}${chk}`
            }
            else return '037F2312'
        }
        else return '037F2310'
    }

    function spaceBetween(s) {
        let res = ''
        for (let i = 0; i < s.length; i += 2) {
            res += s[i] + s[i + 1] + ' '
        }
        return res
    }

    function logRX(cmd) {
        if (chkCheck(cmd)) {
            let s = bufferRX.substring(6, bufferRX.length - 2)
            // console.log(s)
            logArq += s
            return '017D7E'
        }
        else return '037F3D10'
    }

    function finish(cmd) {
        if (chkCheck(cmd)) {
            //salvar log
            saveTextAsFile()
            return '01C2C3'
        }
        else return '037F8210'
    }

    function chkCheck(cmd) {
        console.log(`> ${bufferRX}`)
        let chk = getChk(cmd)
        return cmd[cmd.length - 1] == chk
    }

    function getChk(cmd) {
        let vet = []
        vet = cmd.map(e => Number('0X' + e))
        let chk = vet.reduce(
            (ac, cur, ind) => {
                if (ind < vet.length - 1) ac += parseInt(cur)
                return ac
            }
        )
        // chk = chk.toString(16).toLocaleUpperCase()
        chk = toHex(chk)
        // console.log(chk[chk.length -2] + chk[chk.length -1])
        return chk[chk.length - 2] + chk[chk.length - 1]
    }

    function fileOpen(callback) {
        if (window.File && window.FileReader && window.FileList && window.Blob) {

            var fileSelected = document.getElementById('txtfiletoread');
            fileSelected.addEventListener('change', function (e) {

                //Set the extension for the file
                var fileExtension = /text.*/;
                //Get the file object
                var fileTobeRead = fileSelected.files[0];
                //Check of the extension match
                if (fileTobeRead.type.match(fileExtension)) {
                    //Initialize the FileReader object to read the 2file
                    var fileReader = new FileReader();
                    fileReader.onload = function (e) {
                        funcao = fileReader.result.split('\r\n')
                        callback()
                    }
                    fileReader.readAsText(fileTobeRead)
                }
                else {
                    console.log("Por favor selecione arquivo texto");
                }
            }, false);
        }
        else {
            console.log("Arquivo(s) não suportado(s)");
        }
    }

    function saveTextAsFile() {
        var textToSave = logArq;
        // var textToSave = document.getElementById("inputTextToSave").value;
        var textToSaveAsBlob = new Blob([textToSave], { type: "text/plain" });
        var textToSaveAsURL = window.URL.createObjectURL(textToSaveAsBlob);
        var fileNameToSaveAs = 'log';
        // var fileNameToSaveAs = document.getElementById("inputFileNameToSaveAs").value;
        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        downloadLink.href = textToSaveAsURL;
        downloadLink.onclick = destroyClickedElement;
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
    }

    function destroyClickedElement(event) {
        document.body.removeChild(event.target);
    }

    // /* Utils */
    function toHex(d) {
        return ("0" + (Number(d).toString(16))).slice(-2).toUpperCase()
    }

    function getSupportedProperties(characteristic) {
        let supportedProperties = [];
        for (const p in characteristic.properties) {
            if (characteristic.properties[p] === true) {
                supportedProperties.push(p.toUpperCase());
            }
        }
        return '[' + supportedProperties.join(', ') + ']';
    }


    function disabledAllBtn(classe) {
        let btns = document.getElementsByClassName(classe)
        let obj = Object.values(btns)
        obj.forEach(e => {
            e.disabled = true
        })
    }
</script>


</html>
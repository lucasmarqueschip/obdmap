<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <!-- crossorigin="anonymous"> -->

    <title>Bluetooth</title>


    <style>
        .btn {
            font-size: 1.5rem;
        }
        .display{
            display: grid;
            grid-gap: 4px;            
        }
        [wm-ativado]{
            background-color: lime;
        }
    </style>
</head>

<body>
    <div class="display">

        <h1 id="VersionBluetooth">Version: 0.0.82</h1>
        <input type="text" id="name" value="SLAVE" placeholder="Device">

        <div class="display" id="btnDiv">
            <button class="btn" id='btnConnect' onclick="btnConnectClick()">Conectar</button>
            <button class="btn" id='btnDisConnect' onclick="btnDisconnectClick()" disabled>Desconectar</button>
            <button class="btn" id='btnReconnect' onclick="btnReconnectClick()" disabled>Reconectar</button>
            <button class="btn2" id='btnTeste' onclick="btnTesteClick()">Teste</button>
        </div>
        <div id="logs"></div>
    </div>



</body>
<script src="./index.js"></script>
<!-- <script src="./bluetooth.js"></script> -->

<script>
    // esse script será o bluetooth.js
    //fonte: https://googlechrome.github.io/samples/web-bluetooth/
    "use strict";

    var bluetoothDevice
    let myCharacteristic = []


    function ConnectBluetooth(name, classDisable, elementEnabled) {


        log.innerHTML += `Criando conexao: ${name} <br/>`
        let serviceUUiD = '0000fefb-0000-1000-8000-00805f9b34fb'
        let optionalServices = serviceUUiD
            .split(/, ?/).map(s => s.startsWith('0x') ? parseInt(s) : s)
            .filter(s => s && BluetoothUUID.getService);

        // let options = { filters: [] }
        let options = {}
        if (name) {
            options = { filters: [], optionalServices: optionalServices }
            options.filters.push({ name })
        }else{
            options.acceptAllDevices = true
        }
        // log.innerHTML += 'Request Device...' + JSON.stringify(options) + '</br>'
        navigator.bluetooth.requestDevice(options)
            .then(device => {
                bluetoothDevice = device;
                log.innerHTML += 'Conectando: ' + bluetoothDevice.name + '</br>'
                return bluetoothDevice.gatt.connect()
            })
            .then(server => {
                log.innerHTML += 'Conectado: ' + bluetoothDevice.name + '</br>'
                log.innerHTML += 'ID: ' + bluetoothDevice.id + '</br>'
                log.innerHTML += 'Pareado: ' + bluetoothDevice.gatt.connected + '</br>'
                log.innerHTML += 'Get services...' + '</br>'
                return server.getPrimaryServices()
            })
            .then(services => {
                let queue = Promise.resolve();
                disabledAllBtn(classDisable)
                elementEnabled.forEach(e => {
                    e.disabled = false
                })
                services.forEach(service => {
                    queue = queue.then(_ => service.getCharacteristics().then(characteristics => {
                        log.innerHTML += '> Service: ' + service.uuid + '</br>';
                        characteristics.forEach((characteristic, id) => {
                            myCharacteristic.push(characteristic)

                            let sup = getSupportedProperties(characteristic)

                            let element = characteristic.uuid + ' ' + sup + '<br/>'
                            divBtn.innerHTML += `<button class = 'btn btnRX' id='btnChar${id}' onclick=
                                'ServiceOf("${id}")'>${element}</button></br>`


                        });
                    }));
                });
                return queue;
            })
            .catch(error => {
                log.innerHTML += 'Argh! ' + error + '</br>';
            })


    }

    function DisconnectBluetooth(classDisable, elementEnabled) {

        disabledAllBtn(classDisable)
        elementEnabled.forEach(e => {
            e.disabled = false
            log.innerHTML += `Elemento ${e.innerHTML} habilitado<br/>`
        })
        if (!bluetoothDevice) {
            return;
        }
        log.innerHTML += 'Desconectando Bluetooth<br/>'
        if (bluetoothDevice.gatt.connected) {
            bluetoothDevice.gatt.disconnect();
            log.innerHTML += 'Bluetooth desconectado!<br/>'
        } else {
            log.innerHTML += 'Bluetooth já desconectado!!!<br/>'
        }
    }

    function ReconnectBluetooth(classDisable, elementEnabled) {
        disabledAllBtn(classDisable)
        elementEnabled.forEach(e => {
            e.disabled = false
        })
        if (!bluetoothDevice) {
            return;
        }
        log.innerHTML += 'Reconectando Bluetooth...<br/>'
        if (bluetoothDevice.gatt.connected) {
            log.innerHTML += 'Bluetooth já está conectado!!!<br/>'
        } else {
            log.innerHTML += 'Connecting to Bluetooth Device...<br/>';
            return bluetoothDevice.gatt.connect()
                .then(server => {
                    log.innerHTML += '> Bluetooth Device connected<br/>';
                });
        }
    }

    function Teste(data) {
        log.innerHTML += 'Testando...<br/>'


        let writeBuffer = [32]
        var tmpWriteBfr = Uint8Array.from(writeBuffer.splice(0, writeBuffer.length));
        log.innerHTML += tmpWriteBfr + '<br/>'

        // writeBuffer = prompt('Digite o comando', '0F55010110AA')
        // if (writeBuffer != null && writeBuffer != '') {
        //     let bytes = []; // char codes
        //     for (let i = 0; i < writeBuffer.length; ++i) {
        //         bytes = bytes.concat([writeBuffer.charCodeAt(i)]);
        //     }
        //     tmpWriteBfr = Uint8Array.from(bytes.splice(0, writeBuffer.length));

        //     tmpWriteBfr = tmpWriteBfr.map(e => toHex(e))

        //     log.innerHTML += tmpWriteBfr + '<br/>'
        // }

        myCharacteristic[2].writeValue(tmpWriteBfr)
            .then(_ => {
                log.innerHTML += 'Teste: Write Success <br/>'
            })
            .catch(error => {
                log.innerHTML += 'Argh! ' + error + '<br/>'
            })

    }


    function ServiceOf(id) {
        let btnChar = document.getElementById(`btnChar${id}`)

        let serviceOn = btnChar.getAttribute('wm-ativado') == null

        if (serviceOn) {
            if (id == 3 || id == 1) {
                myCharacteristic[id].startNotifications()
                    .then(_ => {
                        log.innerHTML += myCharacteristic[id].uuid.split('-')[0] + ' sucess!!!</br>'
                        myCharacteristic[id].addEventListener('characteristicvaluechanged',
                            handleNotifications);
                        //mostrando ativo no botao                    
                        btnChar.setAttribute('wm-ativado', '')

                    })
                    .catch(error => {
                        log.innerHTML += 'Argh! ' + error + '</br>'
                        log.innerHTML += myCharacteristic[id].uuid + ' não suportado! </br>'
                        log.innerHTML += 'Tentando gravar </br>'
                    })
            } else {
                //gravar
                let writeBuffer = prompt('Digite o comando', '0F55010110AA')
                if (writeBuffer != null && writeBuffer != '') {
                    let bytes = []; // char codes
                    for (let i = 0; i < writeBuffer.length; ++i) {
                        bytes = bytes.concat([writeBuffer.charCodeAt(i)]);
                    }
                    let tmpWriteBfr = Uint8Array.from(bytes.splice(0, writeBuffer.length));
                    myCharacteristic[id].writeValue(tmpWriteBfr)                    
                        .then(_ => {
                            tmpWriteBfr = tmpWriteBfr.map(e => toHex(e))
                            log.innerHTML += `>${tmpWriteBfr}<br/>`
                        })
                        .catch(error => {
                            log.innerHTML += 'Argh! ' + error + '<br/>'
                        })
                } else
                    log.innerHTML += 'Cancelado!<br/>'
            }
        } else {
            // if (myCharacteristic[id]) {
            log.innerHTML += 'Stopping Notifications...';
            btnChar.removeAttribute('wm-ativado')
            myCharacteristic[id].stopNotifications()
                .then(_ => {
                    log.innerHTML += myCharacteristic[id].uuid.split('-')[0] + ' stopped!!!</br>';
                    myCharacteristic[id].removeEventListener('characteristicvaluechanged',
                        handleNotifications);
                })
                .catch(error => {
                    log.innerHTML += 'Argh! ' + error + '</br>';
                });
            // }
        }






    }

    function handleNotifications(event) {
        let value = event.target.value;
        let a = [];
        // Convert raw data bytes to hex values just for the sake of showing something.
        // In the "real" world, you'd use data.getUint8, data.getUint16 or even
        // TextDecoder to process raw data bytes.
        for (let i = 0; i < value.byteLength; i++) {
            a.push(('00' + value.getUint8(i).toString(16)).slice(-2));
        }
        log.innerHTML += '<' + a.join(' ') + '</br>'
    }












    // /* Utils */
    function toHex(d) {
        return ("0" + (Number(d).toString(16))).slice(-2).toUpperCase()
    }

    function getSupportedProperties(characteristic) {
        let supportedProperties = [];
        for (const p in characteristic.properties) {
            if (characteristic.properties[p] === true) {
                supportedProperties.push(p.toUpperCase());
            }
        }
        return '[' + supportedProperties.join(', ') + ']';
    }


    function disabledAllBtn(classe) {
        let btns = document.getElementsByClassName(classe)
        let obj = Object.values(btns)
        obj.forEach(e => {
            e.disabled = true
        })
    }
</script>


</html>